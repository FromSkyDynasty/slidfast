
<!DOCTYPE html>
<html lang="en">

<head>
<title>HTML5 Architecture</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0"/>
<!-- enable full-screen mode -->
<meta name="apple-mobile-web-app-capable" content="yes"/>
<!-- controls the appearance of the status bar in full-screen mode -->
<meta name="apple-mobile-web-app-status-bar-style" content="black"/>
<link rel="stylesheet" media="all" href="demo.css" />
<link rel="stylesheet" media="all" href="../slidfast.css" />
</head>
<body>
<div id="browser">
    <nav class="primary">
        <ul>
            <input type="file" id="files" name="files[]" multiple directory webkitdirectory/>
            <li id="flip-button"><a href="#sf-contact-page" onclick="slidfast.ui.flip('contact-page')">Contact</a></li>
        </ul>
    </nav>

    <div id="page-container">

        <div id="front" class="normal">

           
            <div id="list-container"></div>

            <div id="home-page" class="page">
                
            </div>

        </div>
        <div id="back" class="flipped">

            <div id="contact-page" class="page">
                <h1>Contact Page</h1>
                <a href="demo/contact-map.html" class="fetch">Check out our map!</a>
            </div>

        </div>

    </div>
</div>
<script type="text/javascript" src="../slidfast.js"></script>
<script type="text/javascript">

    slidfast({
        defaultPageID:'home-page',
        touchEnabled: false,
        singlePageModel: true,
        optimizeNetwork: true
    });

</script>

<script>
   var allImages = [], allImagesCopy = [];
  function handleFileSelect(evt) {
    var files = evt.target.files; // FileList object
    

    


    // Loop through the FileList and render image files as thumbnails.

    var displayTime = 10000;

    for (var i = 0, f; f = files[i]; i++) {

      // Only process image files.
      if (!f.type.match('image.*')) {
        continue;
      }

      var reader = new FileReader();

      // Closure to capture the file information.
      reader.onload = (function(theFile,i) {
        return function(e) {
          // Render thumbnail.
          //var span = document.createElement('span');
          var imageID = 'image-' + i;
          //document.getElementById('list-container').innerHTML += ['<div id="',imageID,'" class="page stage-right"><img style="max-width:100%;" class="thumb" src="', e.target.result,
            //                '" title="', escape(theFile.name), '"/></div>'].join('');
          
          //offload to service worker?
          var thisImage = new Image();
          var thisPage = document.createElement('div');
          thisPage.setAttribute('class','page stage-right');
          thisPage.id = imageID;

          thisImage.onload = function(){
            queueForSlideShow(imageID);
          }

          thisImage.src = e.target.result;
          thisImage.setAttribute('style','max-width:100%;');

          thisPage.appendChild(thisImage);
          document.getElementById('list-container').appendChild(thisPage);

        };
      })(f,i);


      ImageTools.resize(f, {
        width: 320, // maximum width
        height: 240 // maximum height
    }, function(blob, didItResize) {
        // didItResize will be true if it managed to resize it, otherwise false (and will return the original file as 'blob')
        //document.getElementById('preview').src = window.URL.createObjectURL(blob);
        // Read in the image file as a data URL.
        console.log(reader.readyState);
        setTimeout(function(){  if(reader.readyState !== 1){reader.readAsDataURL(blob);} },5)
        
        // you can also now upload this blob using an XHR.
    });
      
      
    }


     
    //allImages = Array.from(document.getElementById('list-container').children);
    /*
    var slideshow = setInterval(function(){

        var currentImage = allImages.pop();
        slidfast.ui.slideTo(currentImage);
        console.log(allImages.length)
        if(allImages.length === 0){
            clearInterval(slideshow);
        }

    },5000)

    var cleanup = setInterval(function(){

        var currentImage = allImagesCopy.pop();
        
        document.getElementById(currentImage).remove();

        if(allImagesCopy.length === 0){
            clearInterval(cleanup);
        }

    },10000)
     */
  }


    var currentTime = new Date(),
    timeInQueue = 0;
    function queueForSlideShow(imageId){

        var displayTime = 5000;
        //everytime this method is called an image is loaded. 
        // timeinqueue is total length (in milliseconds) that queue will be active.
        timeInQueue = timeInQueue + displayTime;

        //remove the child with a displayTime offset. 
        //this does not remove image from memory, need to find better way
        setTimeout(function(){
            document.getElementById('list-container').removeChild(document.getElementById(imageId))
        },timeInQueue + displayTime)

        //slide to image at designated time in queue and decrement total queue time
        setTimeout(function(){
            slidfast.ui.slideTo(imageId);
            timeInQueue = timeInQueue - displayTime;
        },timeInQueue)

        
        
    }







    //------------imagetools

if (typeof exports === "undefined") {
    var exports = {};
}

if (typeof module === "undefined") {
   var module = {};
}

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var hasBlobConstructor = typeof Blob !== 'undefined' && (function () {
    try {
        return Boolean(new Blob());
    } catch (e) {
        return false;
    }
})();

var hasArrayBufferViewSupport = hasBlobConstructor && typeof Uint8Array !== 'undefined' && (function () {
    try {
        return new Blob([new Uint8Array(100)]).size === 100;
    } catch (e) {
        return false;
    }
})();

var hasToBlobSupport = typeof HTMLCanvasElement !== "undefined" ? HTMLCanvasElement.prototype.toBlob : false;

var hasBlobSupport = hasToBlobSupport || typeof Uint8Array !== 'undefined' && typeof ArrayBuffer !== 'undefined' && typeof atob !== 'undefined';

var hasReaderSupport = typeof FileReader !== 'undefined' || typeof URL !== 'undefined';

var ImageTools = (function () {
    function ImageTools() {
        _classCallCheck(this, ImageTools);
    }

    _createClass(ImageTools, null, [{
        key: 'resize',
        value: function resize(file, maxDimensions, callback) {
            if (typeof maxDimensions === 'function') {
                callback = maxDimensions;
                maxDimensions = {
                    width: 640,
                    height: 480
                };
            }

            var maxWidth = maxDimensions.width;
            var maxHeight = maxDimensions.height;

            if (!ImageTools.isSupported() || !file.type.match(/image.*/)) {
                callback(file, false);
                return false;
            }

            if (file.type.match(/image\/gif/)) {
                // Not attempting, could be an animated gif
                callback(file, false);
                // TODO: use https://github.com/antimatter15/whammy to convert gif to webm
                return false;
            }

            var image = document.createElement('img');

            image.onload = function (imgEvt) {
                var width = image.width;
                var height = image.height;
                var isTooLarge = false;

                if (width > height && width > maxDimensions.width) {
                    // width is the largest dimension, and it's too big.
                    height *= maxDimensions.width / width;
                    width = maxDimensions.width;
                    isTooLarge = true;
                } else if (height > maxDimensions.height) {
                    // either width wasn't over-size or height is the largest dimension
                    // and the height is over-size
                    width *= maxDimensions.height / height;
                    height = maxDimensions.height;
                    isTooLarge = true;
                }

                if (!isTooLarge) {
                    // early exit; no need to resize
                    callback(file, false);
                    return;
                }

                var canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;

                var ctx = canvas.getContext('2d');
                ctx.drawImage(image, 0, 0, width, height);

                if (hasToBlobSupport) {
                    canvas.toBlob(function (blob) {
                        callback(blob, true);
                    }, file.type);
                } else {
                    var blob = ImageTools._toBlob(canvas, file.type);
                    callback(blob, true);
                }
            };
            ImageTools._loadImage(image, file);

            return true;
        }
    }, {
        key: '_toBlob',
        value: function _toBlob(canvas, type) {
            var dataURI = canvas.toDataURL(type);
            var dataURIParts = dataURI.split(',');
            var byteString = undefined;
            if (dataURIParts[0].indexOf('base64') >= 0) {
                // Convert base64 to raw binary data held in a string:
                byteString = atob(dataURIParts[1]);
            } else {
                // Convert base64/URLEncoded data component to raw binary data:
                byteString = decodeURIComponent(dataURIParts[1]);
            }
            var arrayBuffer = new ArrayBuffer(byteString.length);
            var intArray = new Uint8Array(arrayBuffer);

            for (var i = 0; i < byteString.length; i += 1) {
                intArray[i] = byteString.charCodeAt(i);
            }

            var mimeString = dataURIParts[0].split(':')[1].split(';')[0];
            var blob = null;

            if (hasBlobConstructor) {
                blob = new Blob([hasArrayBufferViewSupport ? intArray : arrayBuffer], { type: mimeString });
            } else {
                var bb = new BlobBuilder();
                bb.append(arrayBuffer);
                blob = bb.getBlob(mimeString);
            }

            return blob;
        }
    }, {
        key: '_loadImage',
        value: function _loadImage(image, file, callback) {
            if (typeof URL === 'undefined') {
                var reader = new FileReader();
                reader.onload = function (evt) {
                    image.src = evt.target.result;
                    if (callback) {
                        callback();
                    }
                };
                reader.readAsDataURL(file);
            } else {
                image.src = URL.createObjectURL(file);
                if (callback) {
                    callback();
                }
            }
        }
    }, {
        key: 'isSupported',
        value: function isSupported() {
            return typeof HTMLCanvasElement !== 'undefined' && hasBlobSupport && hasReaderSupport;
        }
    }]);

    return ImageTools;
})();

exports['default'] = ImageTools;
module.exports = exports['default'];
    

  document.getElementById('files').addEventListener('change', handleFileSelect, false);


    

</script>

</body>
</html>